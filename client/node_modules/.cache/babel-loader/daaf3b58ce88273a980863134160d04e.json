{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require(\"react\");\n\nvar _storeShape = require(\"react-redux/lib/utils/storeShape\");\n\nvar _storeShape2 = _interopRequireDefault(_storeShape);\n\nvar _shallowEqual = require(\"react-redux/lib/utils/shallowEqual\");\n\nvar _shallowEqual2 = _interopRequireDefault(_shallowEqual);\n\nvar _warning = require(\"react-redux/lib/utils/warning\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _isPlainObject = require(\"lodash/isPlainObject\");\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _hoistNonReactStatics = require(\"hoist-non-react-statics\");\n\nvar _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);\n\nvar _invariant = require(\"invariant\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar defaultMapStateToProps = function defaultMapStateToProps(state) {\n  return {};\n}; // eslint-disable-line no-unused-vars\n\n\nvar defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {\n  return _extends({}, parentProps, stateProps, dispatchProps);\n};\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nvar errorObject = {\n  value: null\n};\n\nfunction tryCatch(fn, ctx) {\n  try {\n    return fn.apply(ctx);\n  } catch (e) {\n    errorObject.value = e;\n    return errorObject;\n  }\n}\n\nvar nextVersion = 0;\n\nfunction translatable(mapStateToProps, mapDispatchToProps, mergeProps) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var shouldSubscribe = Boolean(mapStateToProps);\n  var mapState = mapStateToProps || defaultMapStateToProps;\n\n  var mapDispatch = function mapDispatch(dispatch) {\n    return {\n      changeLocale: function changeLocale(locale) {\n        dispatch({\n          type: \"LOCALE_CHANGED\",\n          locale: locale\n        });\n      }\n    };\n  };\n\n  var finalMergeProps = mergeProps || defaultMergeProps;\n  var _options$pure = options.pure,\n      pure = _options$pure === undefined ? true : _options$pure,\n      _options$withRef = options.withRef,\n      withRef = _options$withRef === undefined ? false : _options$withRef;\n  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps; // Helps track hot reloading.\n\n  var version = nextVersion++;\n  return function wrapWithTranslate(WrappedComponent) {\n    var connectDisplayName = \"Translated(\" + getDisplayName(WrappedComponent) + \")\";\n\n    function checkStateShape(props, methodName) {\n      if (!(0, _isPlainObject2.default)(props)) {\n        (0, _warning2.default)(methodName + \"() in \" + connectDisplayName + \" must return a plain object. \" + (\"Instead received \" + props + \".\"));\n      }\n    }\n\n    function computeMergedProps(stateProps, dispatchProps, parentProps) {\n      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkStateShape(mergedProps, 'mergeProps');\n      }\n\n      return mergedProps;\n    }\n\n    var Translated = function (_Component) {\n      _inherits(Translated, _Component);\n\n      _createClass(Translated, [{\n        key: \"shouldComponentUpdate\",\n        value: function shouldComponentUpdate() {\n          return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;\n        }\n      }]);\n\n      function Translated(props, context) {\n        _classCallCheck(this, Translated);\n\n        var _this = _possibleConstructorReturn(this, (Translated.__proto__ || Object.getPrototypeOf(Translated)).call(this, props, context));\n\n        _this.version = version;\n        _this.store = props.store || context.store;\n        (0, _invariant2.default)(_this.store, \"Could not find \\\"store\\\" in either the context or \" + (\"props of \\\"\" + connectDisplayName + \"\\\". \") + \"Either wrap the root component in a <Provider>, \" + (\"or explicitly pass \\\"store\\\" as a prop to \\\"\" + connectDisplayName + \"\\\".\"));\n\n        var storeState = _this.store.getState();\n\n        _this.state = {\n          storeState: storeState\n        };\n\n        _this.clearCache();\n\n        return _this;\n      }\n\n      _createClass(Translated, [{\n        key: \"computeStateProps\",\n        value: function computeStateProps(store, props) {\n          if (!this.finalMapStateToProps) {\n            return this.configureFinalMapState(store, props);\n          }\n\n          var locales = translatable.prototype.locales;\n          var locale = locales[store.getState().locale];\n          var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(locale, props) : this.finalMapStateToProps(locale);\n\n          if (process.env.NODE_ENV !== 'production') {\n            checkStateShape(stateProps, 'mapStateToProps');\n          }\n\n          return stateProps;\n        }\n      }, {\n        key: \"configureFinalMapState\",\n        value: function configureFinalMapState(store, props) {\n          var locales = translatable.prototype.locales;\n          var locale = locales[store.getState().locale];\n          var mappedState = mapState(locale, props);\n          var isFactory = typeof mappedState === 'function';\n          this.finalMapStateToProps = isFactory ? mappedState : mapState;\n          this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;\n\n          if (isFactory) {\n            return this.computeStateProps(store, props);\n          }\n\n          if (process.env.NODE_ENV !== 'production') {\n            checkStateShape(mappedState, 'mapStateToProps');\n          }\n\n          return mappedState;\n        }\n      }, {\n        key: \"computeDispatchProps\",\n        value: function computeDispatchProps(store, props) {\n          if (!this.finalMapDispatchToProps) {\n            return this.configureFinalMapDispatch(store, props);\n          }\n\n          var dispatch = store.dispatch;\n          var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);\n\n          if (process.env.NODE_ENV !== 'production') {\n            checkStateShape(dispatchProps, 'mapDispatchToProps');\n          }\n\n          return dispatchProps;\n        }\n      }, {\n        key: \"configureFinalMapDispatch\",\n        value: function configureFinalMapDispatch(store, props) {\n          var mappedDispatch = mapDispatch(store.dispatch, props);\n          var isFactory = typeof mappedDispatch === 'function';\n          this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;\n          this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;\n\n          if (isFactory) {\n            return this.computeDispatchProps(store, props);\n          }\n\n          if (process.env.NODE_ENV !== 'production') {\n            checkStateShape(mappedDispatch, 'mapDispatchToProps');\n          }\n\n          return mappedDispatch;\n        }\n      }, {\n        key: \"updateStatePropsIfNeeded\",\n        value: function updateStatePropsIfNeeded() {\n          var nextStateProps = this.computeStateProps(this.store, this.props);\n\n          if (this.stateProps && (0, _shallowEqual2.default)(nextStateProps, this.stateProps)) {\n            return false;\n          }\n\n          this.stateProps = nextStateProps;\n          return true;\n        }\n      }, {\n        key: \"updateDispatchPropsIfNeeded\",\n        value: function updateDispatchPropsIfNeeded() {\n          var nextDispatchProps = this.computeDispatchProps(this.store, this.props);\n\n          if (this.dispatchProps && (0, _shallowEqual2.default)(nextDispatchProps, this.dispatchProps)) {\n            return false;\n          }\n\n          this.dispatchProps = nextDispatchProps;\n          return true;\n        }\n      }, {\n        key: \"updateMergedPropsIfNeeded\",\n        value: function updateMergedPropsIfNeeded() {\n          var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);\n\n          if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2.default)(nextMergedProps, this.mergedProps)) {\n            return false;\n          }\n\n          this.mergedProps = nextMergedProps;\n          return true;\n        }\n      }, {\n        key: \"isSubscribed\",\n        value: function isSubscribed() {\n          return typeof this.unsubscribe === 'function';\n        }\n      }, {\n        key: \"trySubscribe\",\n        value: function trySubscribe() {\n          if (shouldSubscribe && !this.unsubscribe) {\n            this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));\n            this.handleChange();\n          }\n        }\n      }, {\n        key: \"tryUnsubscribe\",\n        value: function tryUnsubscribe() {\n          if (this.unsubscribe) {\n            this.unsubscribe();\n            this.unsubscribe = null;\n          }\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          this.trySubscribe();\n        }\n      }, {\n        key: \"componentWillReceiveProps\",\n        value: function componentWillReceiveProps(nextProps) {\n          if (!pure || !(0, _shallowEqual2.default)(nextProps, this.props)) {\n            this.haveOwnPropsChanged = true;\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.tryUnsubscribe();\n          this.clearCache();\n        }\n      }, {\n        key: \"clearCache\",\n        value: function clearCache() {\n          this.dispatchProps = null;\n          this.stateProps = null;\n          this.mergedProps = null;\n          this.haveOwnPropsChanged = true;\n          this.hasStoreStateChanged = true;\n          this.haveStatePropsBeenPrecalculated = false;\n          this.statePropsPrecalculationError = null;\n          this.renderedElement = null;\n          this.finalMapDispatchToProps = null;\n          this.finalMapStateToProps = null;\n        }\n      }, {\n        key: \"handleChange\",\n        value: function handleChange() {\n          if (!this.unsubscribe) {\n            return;\n          }\n\n          var storeState = this.store.getState();\n          var prevStoreState = this.state.storeState;\n\n          if (pure && prevStoreState === storeState) {\n            return;\n          }\n\n          if (pure && !this.doStatePropsDependOnOwnProps) {\n            var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);\n\n            if (!haveStatePropsChanged) {\n              return;\n            }\n\n            if (haveStatePropsChanged === errorObject) {\n              this.statePropsPrecalculationError = errorObject.value;\n            }\n\n            this.haveStatePropsBeenPrecalculated = true;\n          }\n\n          this.hasStoreStateChanged = true;\n          this.setState({\n            storeState: storeState\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var haveOwnPropsChanged = this.haveOwnPropsChanged,\n              hasStoreStateChanged = this.hasStoreStateChanged,\n              haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated,\n              statePropsPrecalculationError = this.statePropsPrecalculationError,\n              renderedElement = this.renderedElement;\n          this.haveOwnPropsChanged = false;\n          this.hasStoreStateChanged = false;\n          this.haveStatePropsBeenPrecalculated = false;\n          this.statePropsPrecalculationError = null;\n\n          if (statePropsPrecalculationError) {\n            throw statePropsPrecalculationError;\n          }\n\n          var shouldUpdateStateProps = true;\n          var shouldUpdateDispatchProps = true;\n\n          if (pure && renderedElement) {\n            shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;\n            shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;\n          }\n\n          var haveStatePropsChanged = false;\n          var haveDispatchPropsChanged = false;\n\n          if (haveStatePropsBeenPrecalculated) {\n            haveStatePropsChanged = true;\n          } else if (shouldUpdateStateProps) {\n            haveStatePropsChanged = this.updateStatePropsIfNeeded();\n          }\n\n          if (shouldUpdateDispatchProps) {\n            haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();\n          }\n\n          var haveMergedPropsChanged = true;\n\n          if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {\n            haveMergedPropsChanged = this.updateMergedPropsIfNeeded();\n          } else {\n            haveMergedPropsChanged = false;\n          }\n\n          if (!haveMergedPropsChanged && renderedElement) {\n            return renderedElement;\n          }\n\n          if (withRef) {\n            this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {\n              ref: 'wrappedInstance'\n            }));\n          } else {\n            this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);\n          }\n\n          return this.renderedElement;\n        }\n      }]);\n\n      return Translated;\n    }(_react.Component);\n\n    Translated.displayName = connectDisplayName;\n    Translated.WrappedComponent = WrappedComponent;\n    Translated.contextTypes = {\n      store: _storeShape2.default\n    };\n    Translated.propTypes = {\n      store: _storeShape2.default\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      Translated.prototype.componentWillUpdate = function componentWillUpdate() {\n        if (this.version === version) {\n          return;\n        } // We are hot reloading!\n\n\n        this.version = version;\n        this.trySubscribe();\n        this.clearCache();\n      };\n    }\n\n    return (0, _hoistNonReactStatics2.default)(Translated, WrappedComponent);\n  };\n}\n\ntranslatable.prototype.locales = {};\nexports.default = translatable;","map":null,"metadata":{},"sourceType":"script"}